{"version":3,"file":"azure-functions.min.js","mappings":"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","sources":["webpack://@azure/functions/./src/InvocationContext.ts","webpack://@azure/functions/./src/InvocationModel.ts","webpack://@azure/functions/./src/addBindingName.ts","webpack://@azure/functions/./src/app.ts","webpack://@azure/functions/./src/constants.ts","webpack://@azure/functions/./src/converters/fromRpcBindings.ts","webpack://@azure/functions/./src/converters/fromRpcContext.ts","webpack://@azure/functions/./src/converters/fromRpcNullable.ts","webpack://@azure/functions/./src/converters/fromRpcTriggerMetadata.ts","webpack://@azure/functions/./src/converters/fromRpcTypedData.ts","webpack://@azure/functions/./src/converters/toCamelCase.ts","webpack://@azure/functions/./src/converters/toRpcHttp.ts","webpack://@azure/functions/./src/converters/toRpcHttpCookie.ts","webpack://@azure/functions/./src/converters/toRpcNullable.ts","webpack://@azure/functions/./src/converters/toRpcTypedData.ts","webpack://@azure/functions/./src/errors.ts","webpack://@azure/functions/./src/http/HttpRequest.ts","webpack://@azure/functions/./src/http/HttpResponse.ts","webpack://@azure/functions/./src/http/extractHttpUserFromHeaders.ts","webpack://@azure/functions/./src/input.ts","webpack://@azure/functions/./src/output.ts","webpack://@azure/functions/./src/trigger.ts","webpack://@azure/functions/./src/utils/isTrigger.ts","webpack://@azure/functions/./src/utils/nonNull.ts","webpack://@azure/functions/external commonjs2 \"@azure/functions-core\"","webpack://@azure/functions/external commonjs2 \"undici\"","webpack://@azure/functions/external commonjs2 \"url\"","webpack://@azure/functions/external commonjs2 \"util\"","webpack://@azure/functions/webpack/bootstrap","webpack://@azure/functions/./src/index.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport * as types from '@azure/functions';\r\nimport {\r\n    EffectiveFunctionOptions,\r\n    InvocationContextInit,\r\n    LogHandler,\r\n    RetryContext,\r\n    TraceContext,\r\n    TriggerMetadata,\r\n} from '@azure/functions';\r\n\r\nexport class InvocationContext implements types.InvocationContext {\r\n    invocationId: string;\r\n    functionName: string;\r\n    extraInputs: InvocationContextExtraInputs;\r\n    extraOutputs: InvocationContextExtraOutputs;\r\n    retryContext?: RetryContext;\r\n    traceContext?: TraceContext;\r\n    triggerMetadata?: TriggerMetadata;\r\n    options: EffectiveFunctionOptions;\r\n    #userLogHandler: LogHandler;\r\n\r\n    constructor(init?: InvocationContextInit) {\r\n        init = init || {};\r\n        const fallbackString = 'unknown';\r\n        this.invocationId = init.invocationId || fallbackString;\r\n        this.functionName = init.functionName || fallbackString;\r\n        this.extraInputs = new InvocationContextExtraInputs();\r\n        this.extraOutputs = new InvocationContextExtraOutputs();\r\n        this.retryContext = init.retryContext;\r\n        this.traceContext = init.traceContext;\r\n        this.triggerMetadata = init.triggerMetadata;\r\n        this.options = {\r\n            trigger: init.options?.trigger || {\r\n                name: fallbackString,\r\n                type: fallbackString,\r\n            },\r\n            return: init.options?.return,\r\n            extraInputs: init.options?.extraInputs || [],\r\n            extraOutputs: init.options?.extraOutputs || [],\r\n        };\r\n        this.#userLogHandler = init.logHandler || fallbackLogHandler;\r\n    }\r\n\r\n    log(...args: unknown[]): void {\r\n        this.#userLogHandler('information', ...args);\r\n    }\r\n\r\n    trace(...args: unknown[]): void {\r\n        this.#userLogHandler('trace', ...args);\r\n    }\r\n\r\n    debug(...args: unknown[]): void {\r\n        this.#userLogHandler('debug', ...args);\r\n    }\r\n\r\n    info(...args: unknown[]): void {\r\n        this.#userLogHandler('information', ...args);\r\n    }\r\n\r\n    warn(...args: unknown[]): void {\r\n        this.#userLogHandler('warning', ...args);\r\n    }\r\n\r\n    error(...args: unknown[]): void {\r\n        this.#userLogHandler('error', ...args);\r\n    }\r\n}\r\n\r\nclass InvocationContextExtraInputs implements types.InvocationContextExtraInputs {\r\n    #inputs: Record<string, unknown> = {};\r\n    get(inputOrName: types.FunctionInput | string): any {\r\n        const name = typeof inputOrName === 'string' ? inputOrName : inputOrName.name;\r\n        return this.#inputs[name];\r\n    }\r\n    set(inputOrName: types.FunctionInput | string, value: unknown): void {\r\n        const name = typeof inputOrName === 'string' ? inputOrName : inputOrName.name;\r\n        this.#inputs[name] = value;\r\n    }\r\n}\r\n\r\nclass InvocationContextExtraOutputs implements types.InvocationContextExtraOutputs {\r\n    #outputs: Record<string, unknown> = {};\r\n    get(outputOrName: types.FunctionOutput | string): unknown {\r\n        const name = typeof outputOrName === 'string' ? outputOrName : outputOrName.name;\r\n        return this.#outputs[name];\r\n    }\r\n    set(outputOrName: types.FunctionOutput | string, value: unknown): void {\r\n        const name = typeof outputOrName === 'string' ? outputOrName : outputOrName.name;\r\n        this.#outputs[name] = value;\r\n    }\r\n}\r\n\r\nfunction fallbackLogHandler(level: types.LogLevel, ...args: unknown[]): void {\r\n    switch (level) {\r\n        case 'trace':\r\n            console.trace(...args);\r\n            break;\r\n        case 'debug':\r\n            console.debug(...args);\r\n            break;\r\n        case 'information':\r\n            console.info(...args);\r\n            break;\r\n        case 'warning':\r\n            console.warn(...args);\r\n            break;\r\n        case 'critical':\r\n        case 'error':\r\n            console.error(...args);\r\n            break;\r\n        default:\r\n            console.log(...args);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { FunctionHandler } from '@azure/functions';\r\nimport * as coreTypes from '@azure/functions-core';\r\nimport {\r\n    CoreInvocationContext,\r\n    InvocationArguments,\r\n    RpcBindingInfo,\r\n    RpcInvocationResponse,\r\n    RpcLogCategory,\r\n    RpcLogLevel,\r\n    RpcTypedData,\r\n} from '@azure/functions-core';\r\nimport { format } from 'util';\r\nimport { InvocationContext } from './InvocationContext';\r\nimport { returnBindingKey } from './constants';\r\nimport { fromRpcBindings } from './converters/fromRpcBindings';\r\nimport { fromRpcRetryContext, fromRpcTraceContext } from './converters/fromRpcContext';\r\nimport { fromRpcTriggerMetadata } from './converters/fromRpcTriggerMetadata';\r\nimport { fromRpcTypedData } from './converters/fromRpcTypedData';\r\nimport { toCamelCaseValue } from './converters/toCamelCase';\r\nimport { toRpcHttp } from './converters/toRpcHttp';\r\nimport { toRpcTypedData } from './converters/toRpcTypedData';\r\nimport { isHttpTrigger, isTimerTrigger, isTrigger } from './utils/isTrigger';\r\nimport { isDefined, nonNullProp, nonNullValue } from './utils/nonNull';\r\n\r\nexport class InvocationModel implements coreTypes.InvocationModel {\r\n    #isDone = false;\r\n    #coreCtx: CoreInvocationContext;\r\n    #functionName: string;\r\n    #bindings: Record<string, RpcBindingInfo>;\r\n    #triggerType: string;\r\n\r\n    constructor(coreCtx: CoreInvocationContext) {\r\n        this.#coreCtx = coreCtx;\r\n        this.#functionName = nonNullProp(coreCtx.metadata, 'name');\r\n        this.#bindings = nonNullProp(coreCtx.metadata, 'bindings');\r\n        const triggerBinding = nonNullValue(\r\n            Object.values(this.#bindings).find((b) => isTrigger(b.type)),\r\n            'triggerBinding'\r\n        );\r\n        this.#triggerType = nonNullProp(triggerBinding, 'type');\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/require-await\r\n    async getArguments(): Promise<InvocationArguments> {\r\n        const req = this.#coreCtx.request;\r\n\r\n        const context = new InvocationContext({\r\n            invocationId: nonNullProp(this.#coreCtx, 'invocationId'),\r\n            functionName: this.#functionName,\r\n            logHandler: (level: RpcLogLevel, ...args: unknown[]) => this.#userLog(level, ...args),\r\n            retryContext: fromRpcRetryContext(req.retryContext),\r\n            traceContext: fromRpcTraceContext(req.traceContext),\r\n            triggerMetadata: fromRpcTriggerMetadata(req.triggerMetadata, this.#triggerType),\r\n            options: fromRpcBindings(this.#bindings),\r\n        });\r\n\r\n        const inputs: unknown[] = [];\r\n        if (req.inputData) {\r\n            for (const binding of req.inputData) {\r\n                const bindingName = nonNullProp(binding, 'name');\r\n                let input: unknown = fromRpcTypedData(binding.data);\r\n\r\n                const bindingType = this.#bindings[bindingName].type;\r\n                if (isTimerTrigger(bindingType)) {\r\n                    input = toCamelCaseValue(input);\r\n                }\r\n\r\n                if (isTrigger(bindingType)) {\r\n                    inputs.push(input);\r\n                } else {\r\n                    context.extraInputs.set(bindingName, input);\r\n                }\r\n            }\r\n        }\r\n\r\n        return { context, inputs };\r\n    }\r\n\r\n    async invokeFunction(context: InvocationContext, inputs: unknown[], handler: FunctionHandler): Promise<unknown> {\r\n        try {\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n            return await Promise.resolve(handler(inputs[0], context));\r\n        } finally {\r\n            this.#isDone = true;\r\n        }\r\n    }\r\n\r\n    async getResponse(context: InvocationContext, result: unknown): Promise<RpcInvocationResponse> {\r\n        const response: RpcInvocationResponse = { invocationId: this.#coreCtx.invocationId };\r\n\r\n        response.outputData = [];\r\n        let usedReturnValue = false;\r\n        for (const [name, binding] of Object.entries(this.#bindings)) {\r\n            if (binding.direction === 'out') {\r\n                if (name === returnBindingKey) {\r\n                    response.returnValue = await this.#convertOutput(binding, result);\r\n                    usedReturnValue = true;\r\n                } else {\r\n                    const outputValue = await this.#convertOutput(binding, context.extraOutputs.get(name));\r\n                    if (isDefined(outputValue)) {\r\n                        response.outputData.push({ name, data: outputValue });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // This allows the return value of non-HTTP triggered functions to be passed back\r\n        // to the host, even if no explicit output binding is set. In most cases, this is ignored,\r\n        // but e.g., Durable uses this to pass orchestrator state back to the Durable extension, w/o\r\n        // an explicit output binding. See here for more details: https://github.com/Azure/azure-functions-nodejs-library/pull/25\r\n        if (!usedReturnValue && !isHttpTrigger(this.#triggerType)) {\r\n            response.returnValue = toRpcTypedData(result);\r\n        }\r\n\r\n        return response;\r\n    }\r\n\r\n    async #convertOutput(binding: RpcBindingInfo, value: unknown): Promise<RpcTypedData | null | undefined> {\r\n        if (binding.type?.toLowerCase() === 'http') {\r\n            return toRpcHttp(value);\r\n        } else {\r\n            return toRpcTypedData(value);\r\n        }\r\n    }\r\n\r\n    #log(level: RpcLogLevel, logCategory: RpcLogCategory, ...args: unknown[]): void {\r\n        this.#coreCtx.log(level, logCategory, format(...args));\r\n    }\r\n\r\n    #systemLog(level: RpcLogLevel, ...args: unknown[]) {\r\n        this.#log(level, 'system', ...args);\r\n    }\r\n\r\n    #userLog(level: RpcLogLevel, ...args: unknown[]): void {\r\n        if (this.#isDone && this.#coreCtx.state !== 'postInvocationHooks') {\r\n            let badAsyncMsg =\r\n                \"Warning: Unexpected call to 'log' on the context object after function execution has completed. Please check for asynchronous calls that are not awaited. \";\r\n            badAsyncMsg += `Function name: ${this.#functionName}. Invocation Id: ${this.#coreCtx.invocationId}.`;\r\n            this.#systemLog('warning', badAsyncMsg);\r\n        }\r\n        this.#log(level, 'user', ...args);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport { HttpRequest } from './http/HttpRequest';\r\nexport { HttpResponse } from './http/HttpResponse';\r\nexport { InvocationContext } from './InvocationContext';\r\n\r\nconst bindingCounts: Record<string, number> = {};\r\n/**\r\n * If the host spawns multiple workers, it expects the metadata (including binding name) to be the same accross workers\r\n * That means we need to generate binding names in a deterministic fashion, so we'll do that using a count\r\n * There's a tiny risk users register bindings in a non-deterministic order (i.e. async race conditions), but it's okay considering the following:\r\n * 1. We will track the count individually for each binding type. This makes the names more readable and reduces the chances a race condition will matter\r\n * 2. Users can manually specify the name themselves (aka if they're doing weird async stuff) and we will respect that\r\n * More info here: https://github.com/Azure/azure-functions-nodejs-worker/issues/638\r\n */\r\nexport function addBindingName<T extends { type: string; name?: string }>(\r\n    binding: T,\r\n    suffix: string\r\n): T & { name: string } {\r\n    if (!binding.name) {\r\n        let bindingType = binding.type;\r\n        if (!bindingType.toLowerCase().endsWith(suffix.toLowerCase())) {\r\n            bindingType += suffix;\r\n        }\r\n        let count = bindingCounts[bindingType] || 0;\r\n        count += 1;\r\n        bindingCounts[bindingType] = count;\r\n        binding.name = bindingType + count.toString();\r\n    }\r\n    return <T & { name: string }>binding;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {\r\n    CosmosDBFunctionOptions,\r\n    CosmosDBTrigger,\r\n    EventGridFunctionOptions,\r\n    EventHubFunctionOptions,\r\n    FunctionOptions,\r\n    HttpFunctionOptions,\r\n    HttpHandler,\r\n    HttpMethod,\r\n    HttpMethodFunctionOptions,\r\n    ServiceBusQueueFunctionOptions,\r\n    ServiceBusTopicFunctionOptions,\r\n    StorageBlobFunctionOptions,\r\n    StorageQueueFunctionOptions,\r\n    TimerFunctionOptions,\r\n} from '@azure/functions';\r\nimport * as coreTypes from '@azure/functions-core';\r\nimport { CoreInvocationContext, FunctionCallback } from '@azure/functions-core';\r\nimport { InvocationModel } from './InvocationModel';\r\nimport { returnBindingKey, version } from './constants';\r\nimport * as output from './output';\r\nimport * as trigger from './trigger';\r\nimport { isTrigger } from './utils/isTrigger';\r\n\r\nlet coreApi: typeof coreTypes | undefined | null;\r\nfunction tryGetCoreApiLazy(): typeof coreTypes | null {\r\n    if (coreApi === undefined) {\r\n        try {\r\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\r\n            coreApi = <typeof coreTypes>require('@azure/functions-core');\r\n        } catch {\r\n            coreApi = null;\r\n        }\r\n    }\r\n    return coreApi;\r\n}\r\n\r\nclass ProgrammingModel implements coreTypes.ProgrammingModel {\r\n    name = '@azure/functions';\r\n    version = version;\r\n    getInvocationModel(coreCtx: CoreInvocationContext): InvocationModel {\r\n        return new InvocationModel(coreCtx);\r\n    }\r\n}\r\n\r\nlet hasSetup = false;\r\nfunction setup() {\r\n    const coreApi = tryGetCoreApiLazy();\r\n    if (!coreApi) {\r\n        console.warn(\r\n            'WARNING: Failed to detect the Azure Functions runtime. Switching \"@azure/functions\" package to test mode - not all features are supported.'\r\n        );\r\n    } else {\r\n        coreApi.setProgrammingModel(new ProgrammingModel());\r\n    }\r\n    hasSetup = true;\r\n}\r\n\r\nfunction convertToHttpOptions(\r\n    optionsOrHandler: HttpFunctionOptions | HttpHandler,\r\n    method: HttpMethod\r\n): HttpFunctionOptions {\r\n    const options: HttpFunctionOptions =\r\n        typeof optionsOrHandler === 'function' ? { handler: optionsOrHandler } : optionsOrHandler;\r\n    options.methods = [method];\r\n    return options;\r\n}\r\n\r\nexport function get(name: string, optionsOrHandler: HttpMethodFunctionOptions | HttpHandler): void {\r\n    http(name, convertToHttpOptions(optionsOrHandler, 'GET'));\r\n}\r\n\r\nexport function put(name: string, optionsOrHandler: HttpMethodFunctionOptions | HttpHandler): void {\r\n    http(name, convertToHttpOptions(optionsOrHandler, 'PUT'));\r\n}\r\n\r\nexport function post(name: string, optionsOrHandler: HttpMethodFunctionOptions | HttpHandler): void {\r\n    http(name, convertToHttpOptions(optionsOrHandler, 'POST'));\r\n}\r\n\r\nexport function patch(name: string, optionsOrHandler: HttpMethodFunctionOptions | HttpHandler): void {\r\n    http(name, convertToHttpOptions(optionsOrHandler, 'PATCH'));\r\n}\r\n\r\nexport function deleteRequest(name: string, optionsOrHandler: HttpMethodFunctionOptions | HttpHandler): void {\r\n    http(name, convertToHttpOptions(optionsOrHandler, 'DELETE'));\r\n}\r\n\r\nexport function http(name: string, options: HttpFunctionOptions): void {\r\n    options.return ||= output.http({});\r\n    generic(name, {\r\n        trigger: trigger.http({\r\n            authLevel: options.authLevel,\r\n            methods: options.methods,\r\n            route: options.route,\r\n        }),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function timer(name: string, options: TimerFunctionOptions): void {\r\n    generic(name, {\r\n        trigger: trigger.timer({\r\n            schedule: options.schedule,\r\n            runOnStartup: options.runOnStartup,\r\n            useMonitor: options.useMonitor,\r\n        }),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function storageBlob(name: string, options: StorageBlobFunctionOptions): void {\r\n    generic(name, {\r\n        trigger: trigger.storageBlob({\r\n            connection: options.connection,\r\n            path: options.path,\r\n        }),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function storageQueue(name: string, options: StorageQueueFunctionOptions): void {\r\n    generic(name, {\r\n        trigger: trigger.storageQueue({\r\n            connection: options.connection,\r\n            queueName: options.queueName,\r\n        }),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function serviceBusQueue(name: string, options: ServiceBusQueueFunctionOptions): void {\r\n    generic(name, {\r\n        trigger: trigger.serviceBusQueue({\r\n            connection: options.connection,\r\n            queueName: options.queueName,\r\n            isSessionsEnabled: options.isSessionsEnabled,\r\n        }),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function serviceBusTopic(name: string, options: ServiceBusTopicFunctionOptions): void {\r\n    generic(name, {\r\n        trigger: trigger.serviceBusTopic({\r\n            connection: options.connection,\r\n            topicName: options.topicName,\r\n            subscriptionName: options.subscriptionName,\r\n            isSessionsEnabled: options.isSessionsEnabled,\r\n        }),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function eventHub(name: string, options: EventHubFunctionOptions): void {\r\n    generic(name, {\r\n        trigger: trigger.eventHub({\r\n            connection: options.connection,\r\n            eventHubName: options.eventHubName,\r\n            cardinality: options.cardinality,\r\n            consumerGroup: options.consumerGroup,\r\n        }),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function eventGrid(name: string, options: EventGridFunctionOptions): void {\r\n    generic(name, {\r\n        trigger: trigger.eventGrid({}),\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function cosmosDB(name: string, options: CosmosDBFunctionOptions): void {\r\n    let cosmosTrigger: CosmosDBTrigger;\r\n    if ('connectionStringSetting' in options) {\r\n        cosmosTrigger = trigger.cosmosDB({\r\n            checkpointDocumentCount: options.checkpointDocumentCount,\r\n            checkpointInterval: options.checkpointInterval,\r\n            collectionName: options.collectionName,\r\n            connectionStringSetting: options.connectionStringSetting,\r\n            createLeaseCollectionIfNotExists: options.createLeaseCollectionIfNotExists,\r\n            databaseName: options.databaseName,\r\n            feedPollDelay: options.feedPollDelay,\r\n            id: options.id,\r\n            leaseAcquireInterval: options.leaseAcquireInterval,\r\n            leaseCollectionName: options.leaseCollectionName,\r\n            leaseCollectionPrefix: options.leaseCollectionPrefix,\r\n            leaseCollectionThroughput: options.leaseCollectionThroughput,\r\n            leaseConnectionStringSetting: options.leaseConnectionStringSetting,\r\n            leaseDatabaseName: options.leaseDatabaseName,\r\n            leaseExpirationInterval: options.leaseExpirationInterval,\r\n            leaseRenewInterval: options.leaseRenewInterval,\r\n            maxItemsPerInvocation: options.maxItemsPerInvocation,\r\n            partitionKey: options.partitionKey,\r\n            preferredLocations: options.preferredLocations,\r\n            sqlQuery: options.sqlQuery,\r\n            startFromBeginning: options.startFromBeginning,\r\n            useMultipleWriteLocations: options.useMultipleWriteLocations,\r\n        });\r\n    } else {\r\n        cosmosTrigger = trigger.cosmosDB({\r\n            connection: options.connection,\r\n            containerName: options.containerName,\r\n            createLeaseContainerIfNotExists: options.createLeaseContainerIfNotExists,\r\n            databaseName: options.databaseName,\r\n            feedPollDelay: options.feedPollDelay,\r\n            id: options.id,\r\n            leaseAcquireInterval: options.leaseAcquireInterval,\r\n            leaseConnection: options.leaseConnection,\r\n            leaseContainerName: options.leaseContainerName,\r\n            leaseContainerPrefix: options.leaseContainerPrefix,\r\n            leaseDatabaseName: options.leaseDatabaseName,\r\n            leaseExpirationInterval: options.leaseExpirationInterval,\r\n            leaseRenewInterval: options.leaseRenewInterval,\r\n            leasesContainerThroughput: options.leasesContainerThroughput,\r\n            maxItemsPerInvocation: options.maxItemsPerInvocation,\r\n            partitionKey: options.partitionKey,\r\n            preferredLocations: options.preferredLocations,\r\n            sqlQuery: options.sqlQuery,\r\n            startFromBeginning: options.startFromBeginning,\r\n            startFromTime: options.startFromTime,\r\n        });\r\n    }\r\n    generic(name, {\r\n        trigger: cosmosTrigger,\r\n        ...options,\r\n    });\r\n}\r\n\r\nexport function generic(name: string, options: FunctionOptions): void {\r\n    if (!hasSetup) {\r\n        setup();\r\n    }\r\n\r\n    const bindings: Record<string, coreTypes.RpcBindingInfo> = {};\r\n\r\n    const trigger = options.trigger;\r\n    bindings[trigger.name] = {\r\n        ...trigger,\r\n        direction: 'in',\r\n        type: isTrigger(trigger.type) ? trigger.type : trigger.type + 'Trigger',\r\n    };\r\n\r\n    if (options.extraInputs) {\r\n        for (const input of options.extraInputs) {\r\n            bindings[input.name] = {\r\n                ...input,\r\n                direction: 'in',\r\n            };\r\n        }\r\n    }\r\n\r\n    if (options.return) {\r\n        options.return.name = returnBindingKey;\r\n        bindings[options.return.name] = {\r\n            ...options.return,\r\n            direction: 'out',\r\n        };\r\n    }\r\n\r\n    if (options.extraOutputs) {\r\n        for (const output of options.extraOutputs) {\r\n            bindings[output.name] = {\r\n                ...output,\r\n                direction: 'out',\r\n            };\r\n        }\r\n    }\r\n\r\n    const coreApi = tryGetCoreApiLazy();\r\n    if (!coreApi) {\r\n        console.warn(\r\n            `WARNING: Skipping call to register function \"${name}\" because the \"@azure/functions\" package is in test mode.`\r\n        );\r\n    } else {\r\n        coreApi.registerFunction({ name, bindings }, <FunctionCallback>options.handler);\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport const version = '4.0.0-alpha.11';\r\n\r\nexport const returnBindingKey = '$return';\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { EffectiveFunctionOptions, FunctionInput, FunctionOutput, FunctionTrigger } from '@azure/functions';\r\nimport { RpcBindingInfo } from '@azure/functions-core';\r\nimport { returnBindingKey } from '../constants';\r\nimport { isTrigger } from '../utils/isTrigger';\r\nimport { nonNullProp, nonNullValue } from '../utils/nonNull';\r\n\r\nexport function fromRpcBindings(bindings: Record<string, RpcBindingInfo> | null | undefined): EffectiveFunctionOptions {\r\n    let trigger: FunctionTrigger | undefined;\r\n    let returnBinding: FunctionOutput | undefined;\r\n    const extraInputs: FunctionInput[] = [];\r\n    const extraOutputs: FunctionOutput[] = [];\r\n    for (const [name, binding] of Object.entries(nonNullValue(bindings, 'bindings'))) {\r\n        if (isTrigger(binding.type)) {\r\n            trigger = fromRpcBinding(name, binding);\r\n        } else if (name === returnBindingKey) {\r\n            returnBinding = fromRpcBinding(name, binding);\r\n        } else if (binding.direction === 'in') {\r\n            extraInputs.push(fromRpcBinding(name, binding));\r\n        } else if (binding.direction === 'out') {\r\n            extraOutputs.push(fromRpcBinding(name, binding));\r\n        }\r\n    }\r\n    return {\r\n        trigger: nonNullValue(trigger, 'trigger'),\r\n        return: returnBinding,\r\n        extraInputs,\r\n        extraOutputs,\r\n    };\r\n}\r\n\r\nfunction fromRpcBinding(name: string, binding: RpcBindingInfo): FunctionTrigger | FunctionInput | FunctionOutput {\r\n    return {\r\n        ...binding,\r\n        type: nonNullProp(binding, 'type'),\r\n        name,\r\n    };\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Exception, RetryContext, TraceContext } from '@azure/functions';\r\nimport { RpcException, RpcRetryContext, RpcTraceContext } from '@azure/functions-core';\r\nimport { copyPropIfDefined, nonNullProp } from '../utils/nonNull';\r\n\r\nexport function fromRpcRetryContext(retryContext: RpcRetryContext | null | undefined): RetryContext | undefined {\r\n    if (!retryContext) {\r\n        return undefined;\r\n    } else {\r\n        const result: RetryContext = {\r\n            retryCount: nonNullProp(retryContext, 'retryCount'),\r\n            maxRetryCount: nonNullProp(retryContext, 'maxRetryCount'),\r\n        };\r\n        if (retryContext.exception) {\r\n            result.exception = fromRpcException(retryContext.exception);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction fromRpcException(exception: RpcException): Exception {\r\n    const result: Exception = {};\r\n    copyPropIfDefined(exception, result, 'message');\r\n    copyPropIfDefined(exception, result, 'source');\r\n    copyPropIfDefined(exception, result, 'stackTrace');\r\n    return result;\r\n}\r\n\r\nexport function fromRpcTraceContext(traceContext: RpcTraceContext | null | undefined): TraceContext | undefined {\r\n    if (!traceContext) {\r\n        return undefined;\r\n    } else {\r\n        const result: TraceContext = {};\r\n        copyPropIfDefined(traceContext, result, 'traceParent');\r\n        copyPropIfDefined(traceContext, result, 'traceState');\r\n        if (traceContext.attributes) {\r\n            result.attributes = traceContext.attributes;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { RpcNullableString } from '@azure/functions-core';\r\n\r\nexport function fromNullableMapping(\r\n    nullableMapping: Record<string, RpcNullableString> | null | undefined,\r\n    originalMapping?: Record<string, string> | null\r\n): Record<string, string> {\r\n    let converted = {};\r\n    if (nullableMapping && Object.keys(nullableMapping).length > 0) {\r\n        for (const key in nullableMapping) {\r\n            converted[key] = nullableMapping[key].value || '';\r\n        }\r\n    } else if (originalMapping && Object.keys(originalMapping).length > 0) {\r\n        converted = originalMapping;\r\n    }\r\n    return converted;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { TriggerMetadata } from '@azure/functions';\r\nimport { RpcTypedData } from '@azure/functions-core';\r\nimport { isHttpTrigger, isTimerTrigger } from '../utils/isTrigger';\r\nimport { fromRpcTypedData } from './fromRpcTypedData';\r\nimport { toCamelCaseKey, toCamelCaseValue } from './toCamelCase';\r\n\r\nexport function fromRpcTriggerMetadata(\r\n    triggerMetadata: Record<string, RpcTypedData> | null | undefined,\r\n    triggerType: string\r\n): TriggerMetadata | undefined {\r\n    // For http and timer triggers, we will avoid using `triggerMetadata` for a few reasons:\r\n    // 1. It uses `toCamelCase` methods, which can lead to weird casing bugs\r\n    // 2. It's generally a large medley of properties that is difficult for us to document/type\r\n    // 3. We can represent that information on the request & timer objects instead\r\n    if (!triggerMetadata || isHttpTrigger(triggerType) || isTimerTrigger(triggerType)) {\r\n        return undefined;\r\n    } else {\r\n        const result: TriggerMetadata = {};\r\n        for (const [key, value] of Object.entries(triggerMetadata)) {\r\n            result[toCamelCaseKey(key)] = toCamelCaseValue(fromRpcTypedData(value));\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { RpcTypedData } from '@azure/functions-core';\r\nimport { HttpRequest } from '../http/HttpRequest';\r\nimport { isDefined } from '../utils/nonNull';\r\n\r\nexport function fromRpcTypedData(data: RpcTypedData | null | undefined): unknown {\r\n    if (!data) {\r\n        return undefined;\r\n    } else if (isDefined(data.string)) {\r\n        return tryJsonParse(data.string);\r\n    } else if (isDefined(data.json)) {\r\n        return JSON.parse(data.json);\r\n    } else if (isDefined(data.bytes)) {\r\n        return Buffer.from(data.bytes);\r\n    } else if (isDefined(data.stream)) {\r\n        return Buffer.from(data.stream);\r\n    } else if (isDefined(data.http)) {\r\n        return new HttpRequest(data.http);\r\n    } else if (isDefined(data.int)) {\r\n        return data.int;\r\n    } else if (isDefined(data.double)) {\r\n        return data.double;\r\n    } else if (data.collectionBytes && isDefined(data.collectionBytes.bytes)) {\r\n        return data.collectionBytes.bytes.map((d) => Buffer.from(d));\r\n    } else if (data.collectionString && isDefined(data.collectionString.string)) {\r\n        return data.collectionString.string.map(tryJsonParse);\r\n    } else if (data.collectionDouble && isDefined(data.collectionDouble.double)) {\r\n        return data.collectionDouble.double;\r\n    } else if (data.collectionSint64 && isDefined(data.collectionSint64.sint64)) {\r\n        return data.collectionSint64.sint64;\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nfunction tryJsonParse(data: string): unknown {\r\n    try {\r\n        return JSON.parse(data);\r\n    } catch {\r\n        return data;\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport function toCamelCaseValue(data: unknown): unknown {\r\n    if (typeof data !== 'object' || data === null) {\r\n        return data;\r\n    } else if (Array.isArray(data)) {\r\n        return data.map(toCamelCaseValue);\r\n    } else {\r\n        const result = {};\r\n        for (const [key, value] of Object.entries(data)) {\r\n            result[toCamelCaseKey(key)] = toCamelCaseValue(value);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function toCamelCaseKey(key: string): string {\r\n    return key.charAt(0).toLowerCase() + key.slice(1);\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { RpcHttpData, RpcTypedData } from '@azure/functions-core';\r\nimport { AzFuncSystemError } from '../errors';\r\nimport { HttpResponse } from '../http/HttpResponse';\r\nimport { toRpcHttpCookie } from './toRpcHttpCookie';\r\nimport { toRpcTypedData } from './toRpcTypedData';\r\n\r\nexport async function toRpcHttp(data: unknown): Promise<RpcTypedData | null | undefined> {\r\n    if (data === null || data === undefined) {\r\n        return data;\r\n    } else if (typeof data !== 'object') {\r\n        throw new AzFuncSystemError(\r\n            'The HTTP response must be an object with optional properties \"body\", \"status\", \"headers\", and \"cookies\".'\r\n        );\r\n    }\r\n\r\n    const response = data instanceof HttpResponse ? data : new HttpResponse(data);\r\n    const rpcResponse: RpcHttpData = {};\r\n    rpcResponse.statusCode = response.status.toString();\r\n\r\n    rpcResponse.headers = {};\r\n    for (const [key, value] of response.headers.entries()) {\r\n        rpcResponse.headers[key] = value;\r\n    }\r\n\r\n    rpcResponse.cookies = [];\r\n    for (const cookie of response.cookies) {\r\n        rpcResponse.cookies.push(toRpcHttpCookie(cookie));\r\n    }\r\n\r\n    rpcResponse.enableContentNegotiation = response.enableContentNegotiation;\r\n\r\n    const bodyBytes = await response.arrayBuffer();\r\n    rpcResponse.body = toRpcTypedData(bodyBytes);\r\n\r\n    return { http: rpcResponse };\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Cookie } from '@azure/functions';\r\nimport { RpcHttpCookie, RpcHttpCookieSameSite } from '@azure/functions-core';\r\nimport { toNullableBool, toNullableDouble, toNullableString, toNullableTimestamp, toRpcString } from './toRpcNullable';\r\n\r\n/**\r\n * From RFC specifications for 'Set-Cookie' response header: https://www.rfc-editor.org/rfc/rfc6265.txt\r\n * @param inputCookie\r\n */\r\nexport function toRpcHttpCookie(inputCookie: Cookie): RpcHttpCookie {\r\n    // Resolve RpcHttpCookie.SameSite enum, a one-off\r\n    let rpcSameSite: RpcHttpCookieSameSite = 'none';\r\n    if (inputCookie && inputCookie.sameSite) {\r\n        const sameSite = inputCookie.sameSite.toLocaleLowerCase();\r\n        if (sameSite === 'lax') {\r\n            rpcSameSite = 'lax';\r\n        } else if (sameSite === 'strict') {\r\n            rpcSameSite = 'strict';\r\n        } else if (sameSite === 'none') {\r\n            rpcSameSite = 'explicitNone';\r\n        }\r\n    }\r\n\r\n    const rpcCookie: RpcHttpCookie = {\r\n        name: inputCookie && toRpcString(inputCookie.name, 'cookie.name'),\r\n        value: inputCookie && toRpcString(inputCookie.value, 'cookie.value'),\r\n        domain: toNullableString(inputCookie && inputCookie.domain, 'cookie.domain'),\r\n        path: toNullableString(inputCookie && inputCookie.path, 'cookie.path'),\r\n        expires: toNullableTimestamp(inputCookie && inputCookie.expires, 'cookie.expires'),\r\n        secure: toNullableBool(inputCookie && inputCookie.secure, 'cookie.secure'),\r\n        httpOnly: toNullableBool(inputCookie && inputCookie.httpOnly, 'cookie.httpOnly'),\r\n        sameSite: rpcSameSite,\r\n        maxAge: toNullableDouble(inputCookie && inputCookie.maxAge, 'cookie.maxAge'),\r\n    };\r\n\r\n    return rpcCookie;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { RpcNullableBool, RpcNullableDouble, RpcNullableString, RpcNullableTimestamp } from '@azure/functions-core';\r\nimport { AzFuncSystemError } from '../errors';\r\n\r\n/**\r\n * Converts boolean input to an 'INullableBool' to be sent through the RPC layer.\r\n * Input that is not a boolean but is also not null or undefined logs a function app level warning.\r\n * @param nullable Input to be converted to an INullableBool if it is a valid boolean\r\n * @param propertyName The name of the property that the caller will assign the output to. Used for debugging.\r\n */\r\nexport function toNullableBool(nullable: boolean | undefined, propertyName: string): undefined | RpcNullableBool {\r\n    if (typeof nullable === 'boolean') {\r\n        return <RpcNullableBool>{\r\n            value: nullable,\r\n        };\r\n    }\r\n\r\n    if (nullable != null) {\r\n        throw new AzFuncSystemError(\r\n            `A 'boolean' type was expected instead of a '${typeof nullable}' type. Cannot parse value of '${propertyName}'.`\r\n        );\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Converts number or string that parses to a number to an 'INullableDouble' to be sent through the RPC layer.\r\n * Input that is not a valid number but is also not null or undefined logs a function app level warning.\r\n * @param nullable Input to be converted to an INullableDouble if it is a valid number\r\n * @param propertyName The name of the property that the caller will assign the output to. Used for debugging.\r\n */\r\nexport function toNullableDouble(\r\n    nullable: number | string | undefined,\r\n    propertyName: string\r\n): undefined | RpcNullableDouble {\r\n    if (typeof nullable === 'number') {\r\n        return <RpcNullableDouble>{\r\n            value: nullable,\r\n        };\r\n    } else if (typeof nullable === 'string') {\r\n        if (!isNaN(Number(nullable))) {\r\n            const parsedNumber = parseFloat(nullable);\r\n            return <RpcNullableDouble>{\r\n                value: parsedNumber,\r\n            };\r\n        }\r\n    }\r\n\r\n    if (nullable != null) {\r\n        throw new AzFuncSystemError(\r\n            `A 'number' type was expected instead of a '${typeof nullable}' type. Cannot parse value of '${propertyName}'.`\r\n        );\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Converts string input to an 'INullableString' to be sent through the RPC layer.\r\n * Input that is not a string but is also not null or undefined logs a function app level warning.\r\n * @param nullable Input to be converted to an INullableString if it is a valid string\r\n * @param propertyName The name of the property that the caller will assign the output to. Used for debugging.\r\n */\r\nexport function toRpcString(nullable: string | undefined, propertyName: string): string {\r\n    if (typeof nullable === 'string') {\r\n        return nullable;\r\n    }\r\n\r\n    if (nullable != null) {\r\n        throw new AzFuncSystemError(\r\n            `A 'string' type was expected instead of a '${typeof nullable}' type. Cannot parse value of '${propertyName}'.`\r\n        );\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\n/**\r\n * Converts string input to an 'INullableString' to be sent through the RPC layer.\r\n * Input that is not a string but is also not null or undefined logs a function app level warning.\r\n * @param nullable Input to be converted to an INullableString if it is a valid string\r\n * @param propertyName The name of the property that the caller will assign the output to. Used for debugging.\r\n */\r\nexport function toNullableString(nullable: string | undefined, propertyName: string): undefined | RpcNullableString {\r\n    if (typeof nullable === 'string') {\r\n        return <RpcNullableString>{\r\n            value: nullable,\r\n        };\r\n    }\r\n\r\n    if (nullable != null) {\r\n        throw new AzFuncSystemError(\r\n            `A 'string' type was expected instead of a '${typeof nullable}' type. Cannot parse value of '${propertyName}'.`\r\n        );\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Converts Date or number input to an 'INullableTimestamp' to be sent through the RPC layer.\r\n * Input that is not a Date or number but is also not null or undefined logs a function app level warning.\r\n * @param nullable Input to be converted to an INullableTimestamp if it is valid input\r\n * @param propertyName The name of the property that the caller will assign the output to. Used for debugging.\r\n */\r\nexport function toNullableTimestamp(\r\n    dateTime: Date | number | undefined,\r\n    propertyName: string\r\n): RpcNullableTimestamp | undefined {\r\n    if (dateTime != null) {\r\n        try {\r\n            const timeInMilliseconds = typeof dateTime === 'number' ? dateTime : dateTime.getTime();\r\n\r\n            if (timeInMilliseconds && timeInMilliseconds >= 0) {\r\n                return {\r\n                    value: {\r\n                        seconds: Math.round(timeInMilliseconds / 1000),\r\n                    },\r\n                };\r\n            }\r\n        } catch {\r\n            throw new AzFuncSystemError(\r\n                `A 'number' or 'Date' input was expected instead of a '${typeof dateTime}'. Cannot parse value of '${propertyName}'.`\r\n            );\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { RpcTypedData } from '@azure/functions-core';\r\n\r\nexport function toRpcTypedData(data: unknown): RpcTypedData | null | undefined {\r\n    if (data === null || data === undefined) {\r\n        return data;\r\n    } else if (typeof data === 'string') {\r\n        return { string: data };\r\n    } else if (Buffer.isBuffer(data)) {\r\n        return { bytes: data };\r\n    } else if (ArrayBuffer.isView(data)) {\r\n        const bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n        return { bytes: bytes };\r\n    } else if (data instanceof ArrayBuffer) {\r\n        const bytes = new Uint8Array(data);\r\n        return { bytes: bytes };\r\n    } else if (typeof data === 'number') {\r\n        if (Number.isInteger(data)) {\r\n            return { int: data };\r\n        } else {\r\n            return { double: data };\r\n        }\r\n    } else {\r\n        return { json: JSON.stringify(data) };\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport interface AzFuncError {\r\n    /**\r\n     * System errors can be tracked in our telemetry\r\n     * User errors cannot be tracked in our telemetry because they could have user information (users can still track it themselves in their app insights resource)\r\n     */\r\n    isAzureFunctionsSystemError: boolean;\r\n}\r\n\r\nexport class AzFuncSystemError extends Error {\r\n    isAzureFunctionsSystemError = true;\r\n}\r\n\r\nexport class AzFuncTypeError extends TypeError implements AzFuncError {\r\n    isAzureFunctionsSystemError = true;\r\n}\r\n\r\nexport class AzFuncRangeError extends RangeError implements AzFuncError {\r\n    isAzureFunctionsSystemError = true;\r\n}\r\n\r\nexport class ReadOnlyError extends AzFuncTypeError {\r\n    constructor(propertyName: string) {\r\n        super(`Cannot assign to read only property '${propertyName}'`);\r\n    }\r\n}\r\n\r\nexport function ensureErrorType(err: unknown): Error & Partial<AzFuncError> {\r\n    if (err instanceof Error) {\r\n        return err;\r\n    } else {\r\n        let message: string;\r\n        if (err === undefined || err === null) {\r\n            message = 'Unknown error';\r\n        } else if (typeof err === 'string') {\r\n            message = err;\r\n        } else if (typeof err === 'object') {\r\n            message = JSON.stringify(err);\r\n        } else {\r\n            message = String(err);\r\n        }\r\n        return new Error(message);\r\n    }\r\n}\r\n\r\n/**\r\n * This is mostly for callbacks where `null` or `undefined` indicates there is no error\r\n * By contrast, anything thrown/caught is assumed to be an error regardless of what it is\r\n */\r\nexport function isError(err: unknown): boolean {\r\n    return err !== null && err !== undefined;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport * as types from '@azure/functions';\r\nimport { HttpRequestParams, HttpRequestUser } from '@azure/functions';\r\nimport { RpcHttpData } from '@azure/functions-core';\r\nimport { Blob } from 'buffer';\r\nimport { ReadableStream } from 'stream/web';\r\nimport { FormData, Headers, Request as uRequest } from 'undici';\r\nimport { URLSearchParams } from 'url';\r\nimport { fromNullableMapping } from '../converters/fromRpcNullable';\r\nimport { nonNullProp } from '../utils/nonNull';\r\nimport { extractHttpUserFromHeaders } from './extractHttpUserFromHeaders';\r\n\r\nexport class HttpRequest implements types.HttpRequest {\r\n    readonly query: URLSearchParams;\r\n    readonly params: HttpRequestParams;\r\n\r\n    #cachedUser?: HttpRequestUser | null;\r\n    #uReq: uRequest;\r\n    #body?: Buffer | string;\r\n\r\n    constructor(rpcHttp: RpcHttpData) {\r\n        const url = nonNullProp(rpcHttp, 'url');\r\n\r\n        if (rpcHttp.body?.bytes) {\r\n            this.#body = Buffer.from(rpcHttp.body?.bytes);\r\n        } else if (rpcHttp.body?.string) {\r\n            this.#body = rpcHttp.body.string;\r\n        }\r\n\r\n        this.#uReq = new uRequest(url, {\r\n            body: this.#body,\r\n            method: nonNullProp(rpcHttp, 'method'),\r\n            headers: fromNullableMapping(rpcHttp.nullableHeaders, rpcHttp.headers),\r\n        });\r\n\r\n        this.query = new URLSearchParams(fromNullableMapping(rpcHttp.nullableQuery, rpcHttp.query));\r\n        this.params = fromNullableMapping(rpcHttp.nullableParams, rpcHttp.params);\r\n    }\r\n\r\n    get url(): string {\r\n        return this.#uReq.url;\r\n    }\r\n\r\n    get method(): string {\r\n        return this.#uReq.method;\r\n    }\r\n\r\n    get headers(): Headers {\r\n        return this.#uReq.headers;\r\n    }\r\n\r\n    get user(): HttpRequestUser | null {\r\n        if (this.#cachedUser === undefined) {\r\n            this.#cachedUser = extractHttpUserFromHeaders(this.headers);\r\n        }\r\n\r\n        return this.#cachedUser;\r\n    }\r\n\r\n    get body(): ReadableStream<any> | null {\r\n        return this.#uReq.body;\r\n    }\r\n\r\n    get bodyUsed(): boolean {\r\n        return this.#uReq.bodyUsed;\r\n    }\r\n\r\n    async arrayBuffer(): Promise<ArrayBuffer> {\r\n        return this.#uReq.arrayBuffer();\r\n    }\r\n\r\n    async blob(): Promise<Blob> {\r\n        return this.#uReq.blob();\r\n    }\r\n\r\n    async formData(): Promise<FormData> {\r\n        return this.#uReq.formData();\r\n    }\r\n\r\n    async json(): Promise<unknown> {\r\n        return this.#uReq.json();\r\n    }\r\n\r\n    async text(): Promise<string> {\r\n        return this.#uReq.text();\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport * as types from '@azure/functions';\r\nimport { HttpResponseInit } from '@azure/functions';\r\nimport { Blob } from 'buffer';\r\nimport { ReadableStream } from 'stream/web';\r\nimport { FormData, Headers, Response as uResponse, ResponseInit as uResponseInit } from 'undici';\r\nimport { isDefined } from '../utils/nonNull';\r\n\r\nexport class HttpResponse implements types.HttpResponse {\r\n    readonly cookies: types.Cookie[];\r\n    readonly enableContentNegotiation: boolean;\r\n\r\n    #uRes: uResponse;\r\n\r\n    constructor(resInit?: HttpResponseInit) {\r\n        const uResInit: uResponseInit = { status: resInit?.status, headers: resInit?.headers };\r\n        if (isDefined(resInit?.jsonBody)) {\r\n            this.#uRes = uResponse.json(resInit?.jsonBody, uResInit);\r\n        } else {\r\n            this.#uRes = new uResponse(resInit?.body, uResInit);\r\n        }\r\n\r\n        this.cookies = resInit?.cookies || [];\r\n        this.enableContentNegotiation = !!resInit?.enableContentNegotiation;\r\n    }\r\n\r\n    get status(): number {\r\n        return this.#uRes.status;\r\n    }\r\n\r\n    get headers(): Headers {\r\n        return this.#uRes.headers;\r\n    }\r\n\r\n    get body(): ReadableStream<any> | null {\r\n        return this.#uRes.body;\r\n    }\r\n\r\n    get bodyUsed(): boolean {\r\n        return this.#uRes.bodyUsed;\r\n    }\r\n\r\n    async arrayBuffer(): Promise<ArrayBuffer> {\r\n        return this.#uRes.arrayBuffer();\r\n    }\r\n\r\n    async blob(): Promise<Blob> {\r\n        return this.#uRes.blob();\r\n    }\r\n\r\n    async formData(): Promise<FormData> {\r\n        return this.#uRes.formData();\r\n    }\r\n\r\n    async json(): Promise<unknown> {\r\n        return this.#uRes.json();\r\n    }\r\n\r\n    async text(): Promise<string> {\r\n        return this.#uRes.text();\r\n    }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { HttpRequestUser } from '@azure/functions';\r\nimport { Headers } from 'undici';\r\nimport { nonNullValue } from '../utils/nonNull';\r\n\r\n/* grandfathered in. Should fix when possible */\r\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access */\r\n\r\nexport function extractHttpUserFromHeaders(headers: Headers): HttpRequestUser | null {\r\n    let user: HttpRequestUser | null = null;\r\n\r\n    const clientPrincipal = headers.get('x-ms-client-principal');\r\n    if (clientPrincipal) {\r\n        const claimsPrincipalData = JSON.parse(Buffer.from(clientPrincipal, 'base64').toString('utf-8'));\r\n\r\n        if (claimsPrincipalData['identityProvider']) {\r\n            user = {\r\n                type: 'StaticWebApps',\r\n                id: claimsPrincipalData['userId'],\r\n                username: claimsPrincipalData['userDetails'],\r\n                identityProvider: claimsPrincipalData['identityProvider'],\r\n                claimsPrincipalData,\r\n            };\r\n        } else {\r\n            user = {\r\n                type: 'AppService',\r\n                id: nonNullValue(headers.get('x-ms-client-principal-id'), 'user-id'),\r\n                username: nonNullValue(headers.get('x-ms-client-principal-name'), 'user-name'),\r\n                identityProvider: nonNullValue(headers.get('x-ms-client-principal-idp'), 'user-idp'),\r\n                claimsPrincipalData,\r\n            };\r\n        }\r\n    }\r\n\r\n    return user;\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {\r\n    CosmosDBInput,\r\n    CosmosDBInputOptions,\r\n    FunctionInput,\r\n    GenericInputOptions,\r\n    StorageBlobInput,\r\n    StorageBlobInputOptions,\r\n} from '@azure/functions';\r\nimport { addBindingName } from './addBindingName';\r\n\r\nexport function storageBlob(options: StorageBlobInputOptions): StorageBlobInput {\r\n    return addInputBindingName({\r\n        ...options,\r\n        type: 'blob',\r\n    });\r\n}\r\n\r\nexport function cosmosDB(options: CosmosDBInputOptions): CosmosDBInput {\r\n    return addInputBindingName({\r\n        ...options,\r\n        type: 'cosmosDB',\r\n    });\r\n}\r\n\r\nexport function generic(options: GenericInputOptions): FunctionInput {\r\n    return addInputBindingName(options);\r\n}\r\n\r\nfunction addInputBindingName<T extends { type: string; name?: string }>(binding: T): T & { name: string } {\r\n    return addBindingName(binding, 'Input');\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {\r\n    CosmosDBOutput,\r\n    CosmosDBOutputOptions,\r\n    EventGridOutput,\r\n    EventGridOutputOptions,\r\n    EventHubOutput,\r\n    EventHubOutputOptions,\r\n    FunctionOutput,\r\n    GenericOutputOptions,\r\n    HttpOutput,\r\n    HttpOutputOptions,\r\n    ServiceBusQueueOutput,\r\n    ServiceBusQueueOutputOptions,\r\n    ServiceBusTopicOutput,\r\n    ServiceBusTopicOutputOptions,\r\n    StorageBlobOutput,\r\n    StorageBlobOutputOptions,\r\n    StorageQueueOutput,\r\n    StorageQueueOutputOptions,\r\n} from '@azure/functions';\r\nimport { addBindingName } from './addBindingName';\r\n\r\nexport function http(options: HttpOutputOptions): HttpOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'http',\r\n    });\r\n}\r\n\r\nexport function storageBlob(options: StorageBlobOutputOptions): StorageBlobOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'blob',\r\n    });\r\n}\r\n\r\nexport function storageQueue(options: StorageQueueOutputOptions): StorageQueueOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'queue',\r\n    });\r\n}\r\n\r\nexport function serviceBusQueue(options: ServiceBusQueueOutputOptions): ServiceBusQueueOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'serviceBus',\r\n    });\r\n}\r\n\r\nexport function serviceBusTopic(options: ServiceBusTopicOutputOptions): ServiceBusTopicOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'serviceBus',\r\n    });\r\n}\r\n\r\nexport function eventHub(options: EventHubOutputOptions): EventHubOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'eventHub',\r\n    });\r\n}\r\n\r\nexport function eventGrid(options: EventGridOutputOptions): EventGridOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'eventGrid',\r\n    });\r\n}\r\n\r\nexport function cosmosDB(options: CosmosDBOutputOptions): CosmosDBOutput {\r\n    return addOutputBindingName({\r\n        ...options,\r\n        type: 'cosmosDB',\r\n    });\r\n}\r\n\r\nexport function generic(options: GenericOutputOptions): FunctionOutput {\r\n    return addOutputBindingName(options);\r\n}\r\n\r\nfunction addOutputBindingName<T extends { type: string; name?: string }>(binding: T): T & { name: string } {\r\n    return addBindingName(binding, 'Output');\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {\r\n    CosmosDBTrigger,\r\n    CosmosDBTriggerOptions,\r\n    EventGridTrigger,\r\n    EventGridTriggerOptions,\r\n    EventHubTrigger,\r\n    EventHubTriggerOptions,\r\n    FunctionTrigger,\r\n    GenericTriggerOptions,\r\n    HttpTrigger,\r\n    HttpTriggerOptions,\r\n    ServiceBusQueueTrigger,\r\n    ServiceBusQueueTriggerOptions,\r\n    ServiceBusTopicTrigger,\r\n    ServiceBusTopicTriggerOptions,\r\n    StorageBlobTrigger,\r\n    StorageBlobTriggerOptions,\r\n    StorageQueueTrigger,\r\n    StorageQueueTriggerOptions,\r\n    TimerTrigger,\r\n    TimerTriggerOptions,\r\n} from '@azure/functions';\r\nimport { addBindingName } from './addBindingName';\r\n\r\nexport function http(options: HttpTriggerOptions): HttpTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        authLevel: options.authLevel || 'anonymous',\r\n        methods: options.methods || ['GET', 'POST'],\r\n        type: 'httpTrigger',\r\n    });\r\n}\r\n\r\nexport function timer(options: TimerTriggerOptions): TimerTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'timerTrigger',\r\n    });\r\n}\r\n\r\nexport function storageBlob(options: StorageBlobTriggerOptions): StorageBlobTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'blobTrigger',\r\n    });\r\n}\r\n\r\nexport function storageQueue(options: StorageQueueTriggerOptions): StorageQueueTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'queueTrigger',\r\n    });\r\n}\r\n\r\nexport function serviceBusQueue(options: ServiceBusQueueTriggerOptions): ServiceBusQueueTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'serviceBusTrigger',\r\n    });\r\n}\r\n\r\nexport function serviceBusTopic(options: ServiceBusTopicTriggerOptions): ServiceBusTopicTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'serviceBusTrigger',\r\n    });\r\n}\r\n\r\nexport function eventHub(options: EventHubTriggerOptions): EventHubTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'eventHubTrigger',\r\n    });\r\n}\r\n\r\nexport function eventGrid(options: EventGridTriggerOptions): EventGridTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'eventGridTrigger',\r\n    });\r\n}\r\n\r\nexport function cosmosDB(options: CosmosDBTriggerOptions): CosmosDBTrigger {\r\n    return addTriggerBindingName({\r\n        ...options,\r\n        type: 'cosmosDBTrigger',\r\n    });\r\n}\r\n\r\nexport function generic(options: GenericTriggerOptions): FunctionTrigger {\r\n    return addTriggerBindingName(options);\r\n}\r\n\r\nfunction addTriggerBindingName<T extends { type: string; name?: string }>(binding: T): T & { name: string } {\r\n    return addBindingName(binding, 'Trigger');\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport function isTrigger(typeName: string | undefined | null): boolean {\r\n    return !!typeName && /trigger$/i.test(typeName);\r\n}\r\n\r\nexport function isHttpTrigger(typeName: string | undefined | null): boolean {\r\n    return typeName?.toLowerCase() === 'httptrigger';\r\n}\r\n\r\nexport function isTimerTrigger(typeName: string | undefined | null): boolean {\r\n    return typeName?.toLowerCase() === 'timertrigger';\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { AzFuncSystemError } from '../errors';\r\n\r\n/**\r\n * Retrieves a property by name from an object and checks that it's not null and not undefined.  It is strongly typed\r\n * for the property and will give a compile error if the given name is not a property of the source.\r\n */\r\nexport function nonNullProp<TSource, TKey extends keyof TSource>(\r\n    source: TSource,\r\n    name: TKey\r\n): NonNullable<TSource[TKey]> {\r\n    const value: NonNullable<TSource[TKey]> = <NonNullable<TSource[TKey]>>source[name];\r\n    return nonNullValue(value, <string>name);\r\n}\r\n\r\n/**\r\n * Validates that a given value is not null and not undefined.\r\n */\r\nexport function nonNullValue<T>(value: T | undefined | null, propertyNameOrMessage?: string): T {\r\n    if (value === null || value === undefined) {\r\n        throw new AzFuncSystemError(\r\n            'Internal error: Expected value to be neither null nor undefined' +\r\n                (propertyNameOrMessage ? `: ${propertyNameOrMessage}` : '')\r\n        );\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function copyPropIfDefined<TData, TKey extends keyof TData>(source: TData, destination: TData, key: TKey): void {\r\n    if (source[key] !== null && source[key] !== undefined) {\r\n        destination[key] = source[key];\r\n    }\r\n}\r\n\r\nexport function isDefined<T>(data: T | undefined | null): data is T {\r\n    return data !== null && data !== undefined;\r\n}\r\n","module.exports = require(\"@azure/functions-core\");","module.exports = require(\"undici\");","module.exports = require(\"url\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport * as app from './app';\r\nexport { HttpRequest } from './http/HttpRequest';\r\nexport { HttpResponse } from './http/HttpResponse';\r\nexport * as input from './input';\r\nexport { InvocationContext } from './InvocationContext';\r\nexport * as output from './output';\r\nexport * as trigger from './trigger';\r\n"],"names":["constructor","init","fallbackString","this","invocationId","functionName","extraInputs","InvocationContextExtraInputs","extraOutputs","InvocationContextExtraOutputs","retryContext","traceContext","triggerMetadata","options","trigger","name","type","return","logHandler","fallbackLogHandler","log","args","trace","debug","info","warn","error","get","inputOrName","set","value","outputOrName","level","console","coreCtx","nonNullProp","metadata","triggerBinding","nonNullValue","Object","values","find","b","isTrigger","getArguments","req","request","context","InvocationContext","fromRpcRetryContext","fromRpcTraceContext","fromRpcTriggerMetadata","fromRpcBindings","inputs","inputData","binding","bindingName","input","fromRpcTypedData","data","bindingType","isTimerTrigger","toCamelCaseValue","push","invokeFunction","handler","Promise","resolve","getResponse","result","response","usedReturnValue","entries","direction","returnBindingKey","returnValue","outputValue","isDefined","outputData","isHttpTrigger","toRpcTypedData","toLowerCase","toRpcHttp","logCategory","format","state","badAsyncMsg","HttpRequest","HttpResponse","bindingCounts","suffix","endsWith","count","toString","coreApi","tryGetCoreApiLazy","undefined","ProgrammingModel","version","getInvocationModel","InvocationModel","hasSetup","convertToHttpOptions","optionsOrHandler","method","methods","http","output","generic","authLevel","route","setProgrammingModel","setup","bindings","registerFunction","timer","schedule","runOnStartup","useMonitor","storageBlob","connection","path","storageQueue","queueName","serviceBusQueue","isSessionsEnabled","serviceBusTopic","topicName","subscriptionName","eventHub","eventHubName","cardinality","consumerGroup","eventGrid","cosmosTrigger","cosmosDB","checkpointDocumentCount","checkpointInterval","collectionName","connectionStringSetting","createLeaseCollectionIfNotExists","databaseName","feedPollDelay","id","leaseAcquireInterval","leaseCollectionName","leaseCollectionPrefix","leaseCollectionThroughput","leaseConnectionStringSetting","leaseDatabaseName","leaseExpirationInterval","leaseRenewInterval","maxItemsPerInvocation","partitionKey","preferredLocations","sqlQuery","startFromBeginning","useMultipleWriteLocations","containerName","createLeaseContainerIfNotExists","leaseConnection","leaseContainerName","leaseContainerPrefix","leasesContainerThroughput","startFromTime","fromRpcBinding","returnBinding","retryCount","maxRetryCount","exception","copyPropIfDefined","fromRpcException","attributes","nullableMapping","originalMapping","converted","keys","length","key","triggerType","toCamelCaseKey","tryJsonParse","JSON","parse","string","json","bytes","Buffer","from","stream","int","double","collectionBytes","map","d","collectionString","collectionDouble","collectionSint64","sint64","charAt","slice","Array","isArray","AzFuncSystemError","rpcResponse","statusCode","status","headers","cookies","cookie","toRpcHttpCookie","enableContentNegotiation","bodyBytes","arrayBuffer","body","inputCookie","rpcSameSite","sameSite","toLocaleLowerCase","toRpcString","domain","toNullableString","expires","toNullableTimestamp","secure","toNullableBool","httpOnly","maxAge","toNullableDouble","nullable","propertyName","isNaN","Number","parseFloat","dateTime","timeInMilliseconds","getTime","seconds","Math","round","isBuffer","ArrayBuffer","isView","Uint8Array","buffer","byteOffset","byteLength","isInteger","stringify","Error","isAzureFunctionsSystemError","AzFuncTypeError","TypeError","AzFuncRangeError","RangeError","super","err","message","String","rpcHttp","url","fromNullableMapping","nullableHeaders","query","URLSearchParams","nullableQuery","params","nullableParams","user","extractHttpUserFromHeaders","bodyUsed","blob","formData","text","resInit","uResInit","jsonBody","clientPrincipal","claimsPrincipalData","username","identityProvider","addInputBindingName","addBindingName","addOutputBindingName","addTriggerBindingName","typeName","test","propertyNameOrMessage","source","destination","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}